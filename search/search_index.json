{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Basalt The rock-solid Bash package manager Note that Basalt is still BETA QUALITY and expect BREAKING CHANGES until a post-beta release (v1.0.0) Introduction To install, see Installation To get started, see Getting Started Reference See tab Internals See tab How-tos See tab For supported platforms, see Support For ADR's, see the tab","title":"Basalt"},{"location":"#basalt","text":"The rock-solid Bash package manager Note that Basalt is still BETA QUALITY and expect BREAKING CHANGES until a post-beta release (v1.0.0)","title":"Basalt"},{"location":"#introduction","text":"To install, see Installation To get started, see Getting Started","title":"Introduction"},{"location":"#reference","text":"See tab","title":"Reference"},{"location":"#internals","text":"See tab","title":"Internals"},{"location":"#how-tos","text":"See tab For supported platforms, see Support For ADR's, see the tab","title":"How-tos"},{"location":"support/","text":"Support This is currently a proposed set of supported platforms. CI currently tests different bash versions on the same Ubuntu 20.10 platform Ubuntu \u2714\ufe0f Standard Support \u274c ESM Debian \u2714\ufe0f LTS \u274c ELTS Fedora \u2714\ufe0f Supported Releases \u274c EOL Support openSUSE \u2714\ufe0f Supported Releases \u274c Evergreen macOS \u2714\ufe0f Supported Releases Linux Distribution Bash Version Distribution EOL (Maintenance) Supported Ubuntu 14.04 LTS 4.3 March 7, 2019 \u274c Ubuntu 16.04 LTS 4.3 August 13, 2020 \u274c Ubuntu 18.04 LTS 4.4.p18 April 2023 \u2714\ufe0f Ubuntu 20.04 LTS 5.0 April 2025 \u2714\ufe0f Ubuntu 20.10 5.0 July 2021 \u2714\ufe0f Ubuntu 21.04 5.1 January 2022 \u2714\ufe0f CentOS 6 4.1.p2 November 30th, 2020 \u274c CentOS 7 4.2.p46 June 30th, 2024 \u2714\ufe0f CentOS 8 5.0.p11 December 31, 2021 \u2714\ufe0f Debian 9 Oldstable 4.4 June 30, 2022 \u2714\ufe0f Debian 10 Stable 5.0 June, 2024 \u2714\ufe0f Debian 11 Testing 5.1 Rolling \u274c Debian 12 Unstable 5.1 Rolling \u274c Alpine Linux Edge 5.1.p8 Rolling \u274c Fedora 32 5.0.p17 May 2021 \u274c Fedora 33 5.0.p17 November 2021 \u2714\ufe0f Fedora 34 5.1 May 2022 \u2714\ufe0f Fedora Rawhide 5.1.p8 Rolling \u274c Arch Linux 5.1.p8 Rolling \u2714\ufe0f Void Linux 5.1.p8 Rolling \u2714\ufe0f Gentoo 5.1_p8 Rolling \u2714\ufe0f Linux Mint 18.3 4.3 ? \u274c Linux Mint 20.2 ? ? \u274c Mageia 6 ? September 30th, 2019 \u274c Mageia 7 4.4 December 2022 \u2714\ufe0f Mageia 8 5.1 August 31st, 2022 \u2714\ufe0f Manjaro Stable 5.1.p8 Rolling \u2714\ufe0f Manjaro Testing 5.1.p8 Rolling \u274c Manjaro Unstable 5.1.p8 Rolling \u274c openSUSE Leap 15.2 4.4 December 2021 \u2714\ufe0f openSUSE Leap 15.3 4.4 November 2022 \u2714\ufe0f openSUSE TumbleWeed 5.1.p4 Rolling \u274c Solus 5.1.p8 ? \u274c Raspbian Stable 5.0 ? \u2714\ufe0f *nix Distribution Bash Version Distribution EOL (Maintenance) Supported FreeBSD ? ? ? OpenBSD ? ? ? DragonFly BSD ? ? ? NetBSD ? ? \u274c Slackware 14.2 ? ? ? OmniOS (Illumos) ? ? ? OpenIndiana (Illumos) ? ? ? MacOS Assuming latest Bash, coreutils installed with Brew Homebrew Bash: 5.1.8 Version Supported macOS 10.13 (High Sierra) \u274c macOS 10.14 (Mojave) \u2714\ufe0f macOS 10.15 (Catalina) \u2714\ufe0f macOS 11 (Big Sur) \u2714\ufe0f Windows Type Supported Windows 7 \u274c Windows 8.1 \u274c Windows 10 (Using WSL2 w/ Ubuntu 20.04 LTS ) \u2714\ufe0f Windows 11 (Using WSL2 w/ Ubuntu 20.04 LTS) \u2714\ufe0f Cygwin \u274c","title":"Support"},{"location":"support/#support","text":"This is currently a proposed set of supported platforms. CI currently tests different bash versions on the same Ubuntu 20.10 platform Ubuntu \u2714\ufe0f Standard Support \u274c ESM Debian \u2714\ufe0f LTS \u274c ELTS Fedora \u2714\ufe0f Supported Releases \u274c EOL Support openSUSE \u2714\ufe0f Supported Releases \u274c Evergreen macOS \u2714\ufe0f Supported Releases","title":"Support"},{"location":"support/#linux","text":"Distribution Bash Version Distribution EOL (Maintenance) Supported Ubuntu 14.04 LTS 4.3 March 7, 2019 \u274c Ubuntu 16.04 LTS 4.3 August 13, 2020 \u274c Ubuntu 18.04 LTS 4.4.p18 April 2023 \u2714\ufe0f Ubuntu 20.04 LTS 5.0 April 2025 \u2714\ufe0f Ubuntu 20.10 5.0 July 2021 \u2714\ufe0f Ubuntu 21.04 5.1 January 2022 \u2714\ufe0f CentOS 6 4.1.p2 November 30th, 2020 \u274c CentOS 7 4.2.p46 June 30th, 2024 \u2714\ufe0f CentOS 8 5.0.p11 December 31, 2021 \u2714\ufe0f Debian 9 Oldstable 4.4 June 30, 2022 \u2714\ufe0f Debian 10 Stable 5.0 June, 2024 \u2714\ufe0f Debian 11 Testing 5.1 Rolling \u274c Debian 12 Unstable 5.1 Rolling \u274c Alpine Linux Edge 5.1.p8 Rolling \u274c Fedora 32 5.0.p17 May 2021 \u274c Fedora 33 5.0.p17 November 2021 \u2714\ufe0f Fedora 34 5.1 May 2022 \u2714\ufe0f Fedora Rawhide 5.1.p8 Rolling \u274c Arch Linux 5.1.p8 Rolling \u2714\ufe0f Void Linux 5.1.p8 Rolling \u2714\ufe0f Gentoo 5.1_p8 Rolling \u2714\ufe0f Linux Mint 18.3 4.3 ? \u274c Linux Mint 20.2 ? ? \u274c Mageia 6 ? September 30th, 2019 \u274c Mageia 7 4.4 December 2022 \u2714\ufe0f Mageia 8 5.1 August 31st, 2022 \u2714\ufe0f Manjaro Stable 5.1.p8 Rolling \u2714\ufe0f Manjaro Testing 5.1.p8 Rolling \u274c Manjaro Unstable 5.1.p8 Rolling \u274c openSUSE Leap 15.2 4.4 December 2021 \u2714\ufe0f openSUSE Leap 15.3 4.4 November 2022 \u2714\ufe0f openSUSE TumbleWeed 5.1.p4 Rolling \u274c Solus 5.1.p8 ? \u274c Raspbian Stable 5.0 ? \u2714\ufe0f","title":"Linux"},{"location":"support/#nix","text":"Distribution Bash Version Distribution EOL (Maintenance) Supported FreeBSD ? ? ? OpenBSD ? ? ? DragonFly BSD ? ? ? NetBSD ? ? \u274c Slackware 14.2 ? ? ? OmniOS (Illumos) ? ? ? OpenIndiana (Illumos) ? ? ?","title":"*nix"},{"location":"support/#macos","text":"Assuming latest Bash, coreutils installed with Brew Homebrew Bash: 5.1.8 Version Supported macOS 10.13 (High Sierra) \u274c macOS 10.14 (Mojave) \u2714\ufe0f macOS 10.15 (Catalina) \u2714\ufe0f macOS 11 (Big Sur) \u2714\ufe0f","title":"MacOS"},{"location":"support/#windows","text":"Type Supported Windows 7 \u274c Windows 8.1 \u274c Windows 10 (Using WSL2 w/ Ubuntu 20.04 LTS ) \u2714\ufe0f Windows 11 (Using WSL2 w/ Ubuntu 20.04 LTS) \u2714\ufe0f Cygwin \u274c","title":"Windows"},{"location":"architecture/ADR-1/","text":"ADR 1: Restructure per-project dependencies Status Accepted Context Currently, for a per-project installation, all dependencies are installed to the ./.basalt directory. The way transitive dependencies are installed create some issues. For example, if B is a dependency of A, it will be installed in the ./.basalt directory of package A. This creates a deep hierarchy (early versions of npm ran into this) Decision When installing dependencies for a per-project installation, all dependencies should be hoisted to the top level ./.basalt directory, or to the ./.basalt directory. To prevent version conflicts, version numbers are appended to the package when downloading and extracting. For example, if package-b@v0.1.0 is a dependency of package-a@v0.8.0 , it will be installed to the ./.basalt/transitive directory. More details can be found in Package Installation Consequences Negatives Current users of basalt will have to completely remove their previous .basalt directory, and reinstall packages. Since the main ./.basalt/bin , ./.basalt/completions , and ./.basalt/man directories are not changing, code changes within packages are unnecessary Positives More maintainable and less buggy code Potentially decrease the total disk space of .basalt Easier to introspect source code of packages","title":"ADR 1: Restructure per-project dependencies"},{"location":"architecture/ADR-1/#adr-1-restructure-per-project-dependencies","text":"","title":"ADR 1: Restructure per-project dependencies"},{"location":"architecture/ADR-1/#status","text":"Accepted","title":"Status"},{"location":"architecture/ADR-1/#context","text":"Currently, for a per-project installation, all dependencies are installed to the ./.basalt directory. The way transitive dependencies are installed create some issues. For example, if B is a dependency of A, it will be installed in the ./.basalt directory of package A. This creates a deep hierarchy (early versions of npm ran into this)","title":"Context"},{"location":"architecture/ADR-1/#decision","text":"When installing dependencies for a per-project installation, all dependencies should be hoisted to the top level ./.basalt directory, or to the ./.basalt directory. To prevent version conflicts, version numbers are appended to the package when downloading and extracting. For example, if package-b@v0.1.0 is a dependency of package-a@v0.8.0 , it will be installed to the ./.basalt/transitive directory. More details can be found in Package Installation","title":"Decision"},{"location":"architecture/ADR-1/#consequences","text":"","title":"Consequences"},{"location":"architecture/ADR-1/#negatives","text":"Current users of basalt will have to completely remove their previous .basalt directory, and reinstall packages. Since the main ./.basalt/bin , ./.basalt/completions , and ./.basalt/man directories are not changing, code changes within packages are unnecessary","title":"Negatives"},{"location":"architecture/ADR-1/#positives","text":"More maintainable and less buggy code Potentially decrease the total disk space of .basalt Easier to introspect source code of packages","title":"Positives"},{"location":"architecture/ADR-2/","text":"ADR 2: Simplify project initialization setup Status Accepted Context When initializing a local project, there are several lines of boilerplate code to write. For example, if a package woof has executable ./pkg/bin/woof ), its content must look something like this: # shellcheck shell=bash eval \"$(basalt-package-init)\" basalt.package-init || exit basalt.package-load . \"$BASALT_PACKAGE_DIR/pkg/src/bin/woof.sh\" main.woof \"$@\" Although 10 lines may not seem that much, there is already quite a bit of \"boilerplate drift\". For example, some packages don't have an || exit after basalt.package-init . And, some do, after the eval \"$(basalt-package-init)\" . The multiple lines originated from the early days of Basalt, when the structure of a Bash application or library were still being explored. Now that this question has been answered, there is no utility for the verbosity. Decision Simplify the boilerplate to a single line. Like so: #!/usr/bin/env bash eval \"$(basalt-package-init woof)\" __run \"$@\" Consequences Negatives There'll be two ways to initialize a project in the wild. This can be confusing, since there are two ways to do the same thing. Detailed documentation about the old and new way mitigates this downside. Basalt must be backwards-compatible with the old initialization method for an indefinite period of time. Positives The simplified boilerplate streamlines the setup process for people new to Basalt. Additionally, the extra abstraction makes it easier to change things around internally. Furthermore, the single line of setup makes it easier to add features. For example, a --no-assert-version flag to not exit 1 if the current Bash version doesn't meet the minimum requirements.","title":"ADR 2: Simplify project initialization setup"},{"location":"architecture/ADR-2/#adr-2-simplify-project-initialization-setup","text":"","title":"ADR 2: Simplify project initialization setup"},{"location":"architecture/ADR-2/#status","text":"Accepted","title":"Status"},{"location":"architecture/ADR-2/#context","text":"When initializing a local project, there are several lines of boilerplate code to write. For example, if a package woof has executable ./pkg/bin/woof ), its content must look something like this: # shellcheck shell=bash eval \"$(basalt-package-init)\" basalt.package-init || exit basalt.package-load . \"$BASALT_PACKAGE_DIR/pkg/src/bin/woof.sh\" main.woof \"$@\" Although 10 lines may not seem that much, there is already quite a bit of \"boilerplate drift\". For example, some packages don't have an || exit after basalt.package-init . And, some do, after the eval \"$(basalt-package-init)\" . The multiple lines originated from the early days of Basalt, when the structure of a Bash application or library were still being explored. Now that this question has been answered, there is no utility for the verbosity.","title":"Context"},{"location":"architecture/ADR-2/#decision","text":"Simplify the boilerplate to a single line. Like so: #!/usr/bin/env bash eval \"$(basalt-package-init woof)\" __run \"$@\"","title":"Decision"},{"location":"architecture/ADR-2/#consequences","text":"","title":"Consequences"},{"location":"architecture/ADR-2/#negatives","text":"There'll be two ways to initialize a project in the wild. This can be confusing, since there are two ways to do the same thing. Detailed documentation about the old and new way mitigates this downside. Basalt must be backwards-compatible with the old initialization method for an indefinite period of time.","title":"Negatives"},{"location":"architecture/ADR-2/#positives","text":"The simplified boilerplate streamlines the setup process for people new to Basalt. Additionally, the extra abstraction makes it easier to change things around internally. Furthermore, the single line of setup makes it easier to add features. For example, a --no-assert-version flag to not exit 1 if the current Bash version doesn't meet the minimum requirements.","title":"Positives"},{"location":"how-to/local-projects/","text":"Local Projects Similar to cargo , yarn etc., Basalt allows for the installation of packages on a per-project basis. This page details how to do it with Basalt First, create a project directory mkdir 'my-project' && cd 'my-project' Now, initialize a new project. We'll be passing in --full ; if you want a more minimalist template, pass --bare instead $ basalt init --full Info Cloned github.com/hyperupcall/template-bash Naturally, the most important part of Basalt packages is the basalt.toml file [package] name = 'fox-track' slug = 'fox_track' version = '0.1.0' authors = ['Edwin Kofler <edwin@kofler.dev>'] description = 'A template to get started writing Bash applications and projects' [run] dependencies = ['https://github.com/hyperupcall/bats-common-utils.git@v3.0.0'] sourceDirs = ['pkg/src/public', 'pkg/lib'] builtinDirs = [] binDirs = ['bin'] completionDirs = ['completions'] manDirs = [] [run.shellEnvironment] [run.setOptions] [run.shoptOptions] In short, name is the pretty name for the package. Often, it has the same name as the repository. slug is the string used to prefix all of your functions when you want your package to be consumed as a library. Lastly, sourceDirs are all the directories containing shell files you wish to source. Note that pkg/lib/cmd is not added since it contains files that are entrypoints for new Bash processes A detailed description for each key can be found at reference/basalt_toml To execute this program, simply run $ basalt run fox-track --help fox-track: A fox tracking sample application Commands: show Shows the current fox count set <number> Sets the current fox count add [number] Adds a number to the current fox count. If number is not specified, it defaults to 1 remove [number] Adds a number to the current fox count. If number is not specified, it defaults to 1 Flags: --help Shows the help menu This is similar to running ./bin/fox-track directly, but using basalt run has another benefit: Basalt will look for commands of the specified name not just for the current project, but for all subdependencies as well If you wish to add a dependency to the project, use the add subcommand $ basalt add 'hyperupcall/bats-common-utils' Downloaded github.com/hyperupcall/bats-common-utils@v3.0.0 Extracted github.com/hyperupcall/bats-common-utils@v3.0.0 Transformed github.com/hyperupcall/bats-common-utils@v3.0.0 Basalt will automatically find and download the version corresponding to the latest GitHub release . If there are no GitHub releases, it will use the latest commit. In this case, v3.0.0 was the latest GitHub release You can view the dependencies by looking in basalt.toml or running $ basalt list https://github.com/hyperupcall/bats-common-utils.git@v3.0.0","title":"Local Projects"},{"location":"how-to/local-projects/#local-projects","text":"Similar to cargo , yarn etc., Basalt allows for the installation of packages on a per-project basis. This page details how to do it with Basalt First, create a project directory mkdir 'my-project' && cd 'my-project' Now, initialize a new project. We'll be passing in --full ; if you want a more minimalist template, pass --bare instead $ basalt init --full Info Cloned github.com/hyperupcall/template-bash Naturally, the most important part of Basalt packages is the basalt.toml file [package] name = 'fox-track' slug = 'fox_track' version = '0.1.0' authors = ['Edwin Kofler <edwin@kofler.dev>'] description = 'A template to get started writing Bash applications and projects' [run] dependencies = ['https://github.com/hyperupcall/bats-common-utils.git@v3.0.0'] sourceDirs = ['pkg/src/public', 'pkg/lib'] builtinDirs = [] binDirs = ['bin'] completionDirs = ['completions'] manDirs = [] [run.shellEnvironment] [run.setOptions] [run.shoptOptions] In short, name is the pretty name for the package. Often, it has the same name as the repository. slug is the string used to prefix all of your functions when you want your package to be consumed as a library. Lastly, sourceDirs are all the directories containing shell files you wish to source. Note that pkg/lib/cmd is not added since it contains files that are entrypoints for new Bash processes A detailed description for each key can be found at reference/basalt_toml To execute this program, simply run $ basalt run fox-track --help fox-track: A fox tracking sample application Commands: show Shows the current fox count set <number> Sets the current fox count add [number] Adds a number to the current fox count. If number is not specified, it defaults to 1 remove [number] Adds a number to the current fox count. If number is not specified, it defaults to 1 Flags: --help Shows the help menu This is similar to running ./bin/fox-track directly, but using basalt run has another benefit: Basalt will look for commands of the specified name not just for the current project, but for all subdependencies as well If you wish to add a dependency to the project, use the add subcommand $ basalt add 'hyperupcall/bats-common-utils' Downloaded github.com/hyperupcall/bats-common-utils@v3.0.0 Extracted github.com/hyperupcall/bats-common-utils@v3.0.0 Transformed github.com/hyperupcall/bats-common-utils@v3.0.0 Basalt will automatically find and download the version corresponding to the latest GitHub release . If there are no GitHub releases, it will use the latest commit. In this case, v3.0.0 was the latest GitHub release You can view the dependencies by looking in basalt.toml or running $ basalt list https://github.com/hyperupcall/bats-common-utils.git@v3.0.0","title":"Local Projects"},{"location":"internals/history/","text":"History Basalt originally started out as a fork of Basher . I liked the behavior of Basher (moreso compared to bpkg ), but there were a few features I wanted to add. Such features are detailed in Motivation After contributing a few PR's to Basher, I decided to fork the project, calling it neobasher since I wanted to make more major modifications. Quickly thereafter, I renamed it to bpm once my modifications became more significant I essentially rewrote most of the codebase, authoring an additional ~100 tests. Some of the features at this point included Support for a bpm.toml file (in addition to backwards-compatible support for package.sh ) Substantially better help output Completion scripts Support for installing many more repositories Support for installing transitive dependencies Improved support for installing different branches / versions Over 250+ tests Although the code was heavily tested, I didn't really like how packages were installed. It was inefficient and had the potential for bugs. When I had this realization, I decided to essentially start from scratch again, coding the design that is implemented today. I threw out the 250+ custom tests, implementations of commands, and nearly everything with the exception of a few low-level parsing functions. Contemporaneously, I renamed the project to basalt , and worked on the from-scratch implementation in a branch called wip until it was subsequently merged into main","title":"History"},{"location":"internals/history/#history","text":"Basalt originally started out as a fork of Basher . I liked the behavior of Basher (moreso compared to bpkg ), but there were a few features I wanted to add. Such features are detailed in Motivation After contributing a few PR's to Basher, I decided to fork the project, calling it neobasher since I wanted to make more major modifications. Quickly thereafter, I renamed it to bpm once my modifications became more significant I essentially rewrote most of the codebase, authoring an additional ~100 tests. Some of the features at this point included Support for a bpm.toml file (in addition to backwards-compatible support for package.sh ) Substantially better help output Completion scripts Support for installing many more repositories Support for installing transitive dependencies Improved support for installing different branches / versions Over 250+ tests Although the code was heavily tested, I didn't really like how packages were installed. It was inefficient and had the potential for bugs. When I had this realization, I decided to essentially start from scratch again, coding the design that is implemented today. I threw out the 250+ custom tests, implementations of commands, and nearly everything with the exception of a few low-level parsing functions. Contemporaneously, I renamed the project to basalt , and worked on the from-scratch implementation in a branch called wip until it was subsequently merged into main","title":"History"},{"location":"internals/motivation/","text":"Motivation A mechanism to facilitate composability within the Bash ecosystem, \u00e1 la a package manager The general idea isn't new; there are many similar projects, but Basalt fills a unique void It is not meant to be a replacement for oh-my-zsh , bash-it , etc. The aforementioned are used only in the context of shell initialization and are more geared towards reusability (not composability) It is unlike bash-oo-framework in that it facilitates the creation of packages like bash-oo-framework . That is, cool features that are a part of bash-oo-framework like stack traces can be installable as a library rather than a greater framework The two existing prominent package managers ( bpkg and Basher ) are most similar, but fall short. Some gripes are listed below bpkg disadvantages Uses a package.json package format that clobbers with NPM's package.json During installation, make is automatically invoked (\"ACE\" on package download) Packages must be supported manually Does not respect the XDG Base Directory specification Basher disadvantages During installation a package.sh is automatically sourced (\"ACE\" on package download) Cannot install specific versions of packages Package names originating from different origins (i.e. github.com vs gitlab.com) clash Has subpar help output and CLI ergonomics (such as argument parsing) bpkg and Basher disadvantages Cannot install multiple packages at once Cannot install local, per-project dependencies Have subpar completion scripts For each tool, the issues were systemic so I forked Basher and made heavy modifications, eventually doing a complete rewrite","title":"Motivation"},{"location":"internals/motivation/#motivation","text":"A mechanism to facilitate composability within the Bash ecosystem, \u00e1 la a package manager The general idea isn't new; there are many similar projects, but Basalt fills a unique void It is not meant to be a replacement for oh-my-zsh , bash-it , etc. The aforementioned are used only in the context of shell initialization and are more geared towards reusability (not composability) It is unlike bash-oo-framework in that it facilitates the creation of packages like bash-oo-framework . That is, cool features that are a part of bash-oo-framework like stack traces can be installable as a library rather than a greater framework The two existing prominent package managers ( bpkg and Basher ) are most similar, but fall short. Some gripes are listed below","title":"Motivation"},{"location":"internals/motivation/#bpkg-disadvantages","text":"Uses a package.json package format that clobbers with NPM's package.json During installation, make is automatically invoked (\"ACE\" on package download) Packages must be supported manually Does not respect the XDG Base Directory specification","title":"bpkg disadvantages"},{"location":"internals/motivation/#basher-disadvantages","text":"During installation a package.sh is automatically sourced (\"ACE\" on package download) Cannot install specific versions of packages Package names originating from different origins (i.e. github.com vs gitlab.com) clash Has subpar help output and CLI ergonomics (such as argument parsing)","title":"Basher disadvantages"},{"location":"internals/motivation/#bpkg-and-basher-disadvantages","text":"Cannot install multiple packages at once Cannot install local, per-project dependencies Have subpar completion scripts For each tool, the issues were systemic so I forked Basher and made heavy modifications, eventually doing a complete rewrite","title":"bpkg and Basher disadvantages"},{"location":"internals/package-installation/","text":"Package Installation This page provides information on how and where packages are installed. The installation of packages is split into four phases. Each of these phases corresponds to a function in pkg.sh Package download pkg.phase_download_tarball() Package extraction pkg.phase_extract_tarball() Package global integration (recursive) pkg.phase_local_integration_recursive() \"$BASALT_GLOBAL_DATA_DIR...\" Package global integration (non-recursive) pkg.phase_local_integration_nonrecursive() \"$BASALT_GLOBAL_DATA_DIR...\" Package local integration (recursive) pkg.phase_local_integration_recursive() \"$BASALT_LOCAL_PROJECT_DIR...\" Package local integration (non-recursive) pkg.phase_local_integration_nonrecursive() \"$BASALT_LOCAL_PROJECT_DIR...\" 1. Package download During this stage, tarballs files are downloaded from the internet to $BASALT_GLOBAL_DATA_DIR/store/tarballs In most cases, tarballs can be downloaded directly. From the point of view of a consumer, you can access these types of tarballs by specifying a revision like @v0.3.0' in dependencies . From the point of view of a package maintainer, enable this behavior by authoring a GitHub release based on a git tag of a Git repository. Doing this is most efficient since the whole Git repository does not need to be downloaded Sometimes, a package consumer may want to use a revision that is not a release (e.g. @e5466e6c3998790ebd99768cf0f910e161b84a95 ). When this type of revision is specified, Basalt will clone the entire repository, then use git-archive(1) to extract the revision in the form of a tarball 2. Package extraction During this stage, tarball files located in $BASALT_GLOBAL_DATA_DIR/store/tarballs are simply extracted and placed in $BASALT_GLOBAL_DATA_DIR/store/packages 3. Global integration (recursive) For each package in $BASALT_GLOBAL_DATA_DIR/store/packages , modifications are done. Find more information about the modifications in \"recursive local integration\" 4. Global integration (non-recursive) For each package in $BASALT_GLOBAL_DATA_DIR/store/packages , modifications are done that don't require recursively resolving subdependencies. Find more information about the modifications in \"non-recursive local integration\" 5. Local integration (recursive) This step involves creating a .basalt directory so the functionality of all dependencies can be properly exposed. The directory is located at $BASALT_LOCAL_PROJECT_DIR/.basalt for local dependencies and at $BASALT_GLOBAL_DATA_DIR/global/.basalt for global dependencies - .basalt/ - bin/ - completion/ - man/ - packages/ - transitive/ - bin/ - completion/ - man/ - packages/ 6. Local integration (non-recursive) This is similar to the previous step, except it performs functionalities that are inherently non recursive. This includes creating the ./basalt/generated subdirectory and the files within it Appending version numbers to all functions Converting the runtime essence of the ./basalt.toml file into other files that are either sourceable or easier to parse","title":"Package Installation"},{"location":"internals/package-installation/#package-installation","text":"This page provides information on how and where packages are installed. The installation of packages is split into four phases. Each of these phases corresponds to a function in pkg.sh Package download pkg.phase_download_tarball() Package extraction pkg.phase_extract_tarball() Package global integration (recursive) pkg.phase_local_integration_recursive() \"$BASALT_GLOBAL_DATA_DIR...\" Package global integration (non-recursive) pkg.phase_local_integration_nonrecursive() \"$BASALT_GLOBAL_DATA_DIR...\" Package local integration (recursive) pkg.phase_local_integration_recursive() \"$BASALT_LOCAL_PROJECT_DIR...\" Package local integration (non-recursive) pkg.phase_local_integration_nonrecursive() \"$BASALT_LOCAL_PROJECT_DIR...\"","title":"Package Installation"},{"location":"internals/package-installation/#1-package-download","text":"During this stage, tarballs files are downloaded from the internet to $BASALT_GLOBAL_DATA_DIR/store/tarballs In most cases, tarballs can be downloaded directly. From the point of view of a consumer, you can access these types of tarballs by specifying a revision like @v0.3.0' in dependencies . From the point of view of a package maintainer, enable this behavior by authoring a GitHub release based on a git tag of a Git repository. Doing this is most efficient since the whole Git repository does not need to be downloaded Sometimes, a package consumer may want to use a revision that is not a release (e.g. @e5466e6c3998790ebd99768cf0f910e161b84a95 ). When this type of revision is specified, Basalt will clone the entire repository, then use git-archive(1) to extract the revision in the form of a tarball","title":"1. Package download"},{"location":"internals/package-installation/#2-package-extraction","text":"During this stage, tarball files located in $BASALT_GLOBAL_DATA_DIR/store/tarballs are simply extracted and placed in $BASALT_GLOBAL_DATA_DIR/store/packages","title":"2. Package extraction"},{"location":"internals/package-installation/#3-global-integration-recursive","text":"For each package in $BASALT_GLOBAL_DATA_DIR/store/packages , modifications are done. Find more information about the modifications in \"recursive local integration\"","title":"3. Global integration (recursive)"},{"location":"internals/package-installation/#4-global-integration-non-recursive","text":"For each package in $BASALT_GLOBAL_DATA_DIR/store/packages , modifications are done that don't require recursively resolving subdependencies. Find more information about the modifications in \"non-recursive local integration\"","title":"4. Global integration (non-recursive)"},{"location":"internals/package-installation/#5-local-integration-recursive","text":"This step involves creating a .basalt directory so the functionality of all dependencies can be properly exposed. The directory is located at $BASALT_LOCAL_PROJECT_DIR/.basalt for local dependencies and at $BASALT_GLOBAL_DATA_DIR/global/.basalt for global dependencies - .basalt/ - bin/ - completion/ - man/ - packages/ - transitive/ - bin/ - completion/ - man/ - packages/","title":"5. Local integration (recursive)"},{"location":"internals/package-installation/#6-local-integration-non-recursive","text":"This is similar to the previous step, except it performs functionalities that are inherently non recursive. This includes creating the ./basalt/generated subdirectory and the files within it Appending version numbers to all functions Converting the runtime essence of the ./basalt.toml file into other files that are either sourceable or easier to parse","title":"6. Local integration (non-recursive)"},{"location":"internals/testing/","text":"Testing What is with '_' in test_util.init_app 'project-foxtrot' '.' \\ \"dependencies = ['file://./subpkg']\" \\ '_' Makes tests go faster since basalt does less processing on the basalt.toml","title":"Testing"},{"location":"internals/testing/#testing","text":"What is with '_' in test_util.init_app 'project-foxtrot' '.' \\ \"dependencies = ['file://./subpkg']\" \\ '_' Makes tests go faster since basalt does less processing on the basalt.toml","title":"Testing"},{"location":"reference/api/","text":"Environment Global Global environment variables are both valid globally (after eval \"$(basalt global init bash)\" ) and locally (after eval \"$(basalt-package-init)\"; basalt.package-init ) BASALT_GLOBAL_REPO The location of the source code. By default (when using the install.sh script), this will be at ${XDG_DATA_HOME:-$HOME/.local/share}/basalt/source . If you move this directory to a different location, the value will be reflected accordingly BASALT_GLOBAL_DATA_DIR The directory Basalt stores nearly all data. This includes downloaded tarballs, directories extracted from tarballs, and the directories that contain global installations of packages. By default, this has the value of ${XDG_DATA_HOME:-$HOME/.local/share}/basalt basalt.load Sources a particular file of a particular package For example, the below example sources the z.sh file that is present at the root of rupa/z . Note that you must pass in the website, as well as the repository owner and repository name basalt.load --global 'github.com/rupa/z' 'z.sh' If you do not pass a file, it will automatically source a load.bash at the root of the repository, if it exists Local Local environment variables are only valid within a Bash package (after eval \"$(basalt-package-init)\"; basalt.package-init ) Note that functions listed here are expected to be called from a Bash execution context BASALT_PACKAGE_DIR The full path to the current project. It is calculated by walking up the file tree from $PWD , only stopping after detecting a ./basalt.toml . The directory that was stopped at is the new value of BASALT_PACKAGE_DIR basalt.package-load Loads all Basalt dependencies basalt.package-load","title":"Environment"},{"location":"reference/api/#environment","text":"","title":"Environment"},{"location":"reference/api/#global","text":"Global environment variables are both valid globally (after eval \"$(basalt global init bash)\" ) and locally (after eval \"$(basalt-package-init)\"; basalt.package-init )","title":"Global"},{"location":"reference/api/#basalt_global_repo","text":"The location of the source code. By default (when using the install.sh script), this will be at ${XDG_DATA_HOME:-$HOME/.local/share}/basalt/source . If you move this directory to a different location, the value will be reflected accordingly","title":"BASALT_GLOBAL_REPO"},{"location":"reference/api/#basalt_global_data_dir","text":"The directory Basalt stores nearly all data. This includes downloaded tarballs, directories extracted from tarballs, and the directories that contain global installations of packages. By default, this has the value of ${XDG_DATA_HOME:-$HOME/.local/share}/basalt","title":"BASALT_GLOBAL_DATA_DIR"},{"location":"reference/api/#basaltload","text":"Sources a particular file of a particular package For example, the below example sources the z.sh file that is present at the root of rupa/z . Note that you must pass in the website, as well as the repository owner and repository name basalt.load --global 'github.com/rupa/z' 'z.sh' If you do not pass a file, it will automatically source a load.bash at the root of the repository, if it exists","title":"basalt.load"},{"location":"reference/api/#local","text":"Local environment variables are only valid within a Bash package (after eval \"$(basalt-package-init)\"; basalt.package-init ) Note that functions listed here are expected to be called from a Bash execution context","title":"Local"},{"location":"reference/api/#basalt_package_dir","text":"The full path to the current project. It is calculated by walking up the file tree from $PWD , only stopping after detecting a ./basalt.toml . The directory that was stopped at is the new value of BASALT_PACKAGE_DIR","title":"BASALT_PACKAGE_DIR"},{"location":"reference/api/#basaltpackage-load","text":"Loads all Basalt dependencies basalt.package-load","title":"basalt.package-load"},{"location":"reference/basalt_conf/","text":"basalt.conf This is a complete reference to the basalt.conf file, found in Bash packages. There are currently two top-level objects: package and run Note that none of these options have any defaults, and arrays must only span single lines Configuration There are two sections to the configuration: [package] : Metadata that describes the package and its purpose. [run] : Metadata that affects how the package is ran (either as a library or executable). When the description of a configuration field mentions a list , it means the field can be specified multiples times. Internally, the field is represented as an array. An example configuration is shown at the way end. [package].type Required. The type of package. Currently, only bash is supported. [package].name Required. The name of the package. [package].namespace Required. The namespace used to prefix all functions. [package].version Required. The current version of the package. [package].author Required. A list of authors. [package].description Required. The package description. [run].dependency Optional. A list of dependencies. By default, it's empty. dependency = https://github.com/hyperupcall/bats-all@v4.6.0 dependency = https://github.com/hyperupcall/bash-core@v0.12.0 dependency = https://github.com/hyperupcall/bash-term@v0.6.3 dependency = https://github.com/hyperupcall/bash-utility@v0.4.0 [run].binDir Optional. A list of binary directories. By default, it has a value of pkg/bin Array of directories that contain executable files. Locally, these files will be symlinked under .basalt/bin ; globally, these files wil be symlinked and available to the current user. [run].sourceDir Optional. A list of directories to source files from. By default, it's empty. Each file in these directories are sourced during the initialization process. In other words, after a package calls basalt.package-init , Basalt will source each file in each directory, for each sourceDir , for each declared package dependency. [run].builtinDir Optional. A list of directories to use as custom dynamic builtins. By default, it has a value of pkg/builtins Array of directories that contain C source code for custom dynamic builtins. These files will automatically be loaded, somewhat analogous to sourceDirs [run].completionDir Optional. A list of directories to use as completion files. By default, it has a value of pkg/completions Array of directories that contain completion scripts. Locally, these files will be symlinked under .basalt/completion ; globally, these files will automatically be made available to the shell after basalt global init <shell> [run].manDir Optional. A list of directories that contain man files. By default, it has a value of pkg/man It does not traverse subdirectories, including man1 , man3 , etc. These files will be symlinked under a man directory in .basalt . Currently, the MANPATH is not modified for global installations; the manpages should be detected automatically [run.env].* Optional. An object of environment variables to inject into your application. By default, it is empty. # TODO [run.env] LANG = C LC_ALL = C [run.setOptions].* Optional. An object of what shell options to enable or disable By default, it is empty. # TODO [run.setOptions] errexit = on pipefail = on [run.shoptOptions].* Optional. An object of bash-specific shell options to enable or disable By default, it is empty. # TODO [run.shoptOptions] extglob = on nullglob = on Example Configuration [package] type = bash name = woof slug = woof version = 0.4.0 author = Edwin Kofler <edwin@kofler.dev> description = The version manager to end all version managers [run] dependency = https://github.com/hyperupcall/bats-all@v4.6.0 dependency = https://github.com/hyperupcall/bash-core@v0.12.0 dependency = https://github.com/hyperupcall/bash-term@v0.6.3 dependency = https://github.com/hyperupcall/bash-utility@v0.4.0 sourceDir = pkg/src/util builtinDir = pkg/builtins binDir = pkg/bin completionDir = pkg/completions [run.setOptions] errexit = on pipefail = on [run.shoptOptions] shift_verbose = on","title":"`basalt.conf`"},{"location":"reference/basalt_conf/#basaltconf","text":"This is a complete reference to the basalt.conf file, found in Bash packages. There are currently two top-level objects: package and run Note that none of these options have any defaults, and arrays must only span single lines","title":"basalt.conf"},{"location":"reference/basalt_conf/#configuration","text":"There are two sections to the configuration: [package] : Metadata that describes the package and its purpose. [run] : Metadata that affects how the package is ran (either as a library or executable). When the description of a configuration field mentions a list , it means the field can be specified multiples times. Internally, the field is represented as an array. An example configuration is shown at the way end.","title":"Configuration"},{"location":"reference/basalt_conf/#packagetype","text":"Required. The type of package. Currently, only bash is supported.","title":"[package].type"},{"location":"reference/basalt_conf/#packagename","text":"Required. The name of the package.","title":"[package].name"},{"location":"reference/basalt_conf/#packagenamespace","text":"Required. The namespace used to prefix all functions.","title":"[package].namespace"},{"location":"reference/basalt_conf/#packageversion","text":"Required. The current version of the package.","title":"[package].version"},{"location":"reference/basalt_conf/#packageauthor","text":"Required. A list of authors.","title":"[package].author"},{"location":"reference/basalt_conf/#packagedescription","text":"Required. The package description.","title":"[package].description"},{"location":"reference/basalt_conf/#rundependency","text":"Optional. A list of dependencies. By default, it's empty. dependency = https://github.com/hyperupcall/bats-all@v4.6.0 dependency = https://github.com/hyperupcall/bash-core@v0.12.0 dependency = https://github.com/hyperupcall/bash-term@v0.6.3 dependency = https://github.com/hyperupcall/bash-utility@v0.4.0","title":"[run].dependency"},{"location":"reference/basalt_conf/#runbindir","text":"Optional. A list of binary directories. By default, it has a value of pkg/bin Array of directories that contain executable files. Locally, these files will be symlinked under .basalt/bin ; globally, these files wil be symlinked and available to the current user.","title":"[run].binDir"},{"location":"reference/basalt_conf/#runsourcedir","text":"Optional. A list of directories to source files from. By default, it's empty. Each file in these directories are sourced during the initialization process. In other words, after a package calls basalt.package-init , Basalt will source each file in each directory, for each sourceDir , for each declared package dependency.","title":"[run].sourceDir"},{"location":"reference/basalt_conf/#runbuiltindir","text":"Optional. A list of directories to use as custom dynamic builtins. By default, it has a value of pkg/builtins Array of directories that contain C source code for custom dynamic builtins. These files will automatically be loaded, somewhat analogous to sourceDirs","title":"[run].builtinDir"},{"location":"reference/basalt_conf/#runcompletiondir","text":"Optional. A list of directories to use as completion files. By default, it has a value of pkg/completions Array of directories that contain completion scripts. Locally, these files will be symlinked under .basalt/completion ; globally, these files will automatically be made available to the shell after basalt global init <shell>","title":"[run].completionDir"},{"location":"reference/basalt_conf/#runmandir","text":"Optional. A list of directories that contain man files. By default, it has a value of pkg/man It does not traverse subdirectories, including man1 , man3 , etc. These files will be symlinked under a man directory in .basalt . Currently, the MANPATH is not modified for global installations; the manpages should be detected automatically","title":"[run].manDir"},{"location":"reference/basalt_conf/#runenv","text":"Optional. An object of environment variables to inject into your application. By default, it is empty. # TODO [run.env] LANG = C LC_ALL = C","title":"[run.env].*"},{"location":"reference/basalt_conf/#runsetoptions","text":"Optional. An object of what shell options to enable or disable By default, it is empty. # TODO [run.setOptions] errexit = on pipefail = on","title":"[run.setOptions].*"},{"location":"reference/basalt_conf/#runshoptoptions","text":"Optional. An object of bash-specific shell options to enable or disable By default, it is empty. # TODO [run.shoptOptions] extglob = on nullglob = on","title":"[run.shoptOptions].*"},{"location":"reference/basalt_conf/#example-configuration","text":"[package] type = bash name = woof slug = woof version = 0.4.0 author = Edwin Kofler <edwin@kofler.dev> description = The version manager to end all version managers [run] dependency = https://github.com/hyperupcall/bats-all@v4.6.0 dependency = https://github.com/hyperupcall/bash-core@v0.12.0 dependency = https://github.com/hyperupcall/bash-term@v0.6.3 dependency = https://github.com/hyperupcall/bash-utility@v0.4.0 sourceDir = pkg/src/util builtinDir = pkg/builtins binDir = pkg/bin completionDir = pkg/completions [run.setOptions] errexit = on pipefail = on [run.shoptOptions] shift_verbose = on","title":"Example Configuration"},{"location":"reference/commands/","text":"Commands basalt add Add a local dependency to your project. The following types of dependencies are supported Local Local dependencies begin with file:// in the basalt.toml . When adding, the dependency must begin with / or ./ Remote Remote dependencies begin with https:// in the basalt.toml . The following forms are accepted: hyperupcall/bash-object github.com/hyperupcall/bash-object https://github.com/hyperupcall/bash-object","title":"Commands"},{"location":"reference/commands/#commands","text":"","title":"Commands"},{"location":"reference/commands/#basalt-add","text":"Add a local dependency to your project. The following types of dependencies are supported","title":"basalt add"},{"location":"reference/commands/#local","text":"Local dependencies begin with file:// in the basalt.toml . When adding, the dependency must begin with / or ./","title":"Local"},{"location":"reference/commands/#remote","text":"Remote dependencies begin with https:// in the basalt.toml . The following forms are accepted: hyperupcall/bash-object github.com/hyperupcall/bash-object https://github.com/hyperupcall/bash-object","title":"Remote"},{"location":"reference/executables/","text":"Executables Wen creating a Bash application, executables are placed in ./pkg/bin/<NAME> . There are two ways this file can properly execute its corresponding file in ./pkg/src/bin/<NAME>.sh ; an new way and an old way. New Way #!/usr/bin/env bash eval \"$(basalt-package-init --no-assert-version woof)\" __run \"$@\" The new way must have at least one argument to basalt-package-init . There are also optional flags, which must come first: --no-assert-version Do not print an error and exit Bash if the minimum Bash version cannot be met. Instead, don't source any dependencies, only run the executable. This is useful if you want an escape hatch from the default behavior if Bash is not the latest version. Old Way The old way exists for backwards compatibility and is not recommended. Please migrate to the more succinct method as the old way may be removed in the future. # shellcheck shell=bash eval \"$(basalt-package-init)\" basalt.package-init || exit basalt.package-load . \"$BASALT_PACKAGE_DIR/pkg/src/bin/shelltest.sh\" main.shelltest \"$@\"","title":"Executables"},{"location":"reference/executables/#executables","text":"Wen creating a Bash application, executables are placed in ./pkg/bin/<NAME> . There are two ways this file can properly execute its corresponding file in ./pkg/src/bin/<NAME>.sh ; an new way and an old way.","title":"Executables"},{"location":"reference/executables/#new-way","text":"#!/usr/bin/env bash eval \"$(basalt-package-init --no-assert-version woof)\" __run \"$@\" The new way must have at least one argument to basalt-package-init . There are also optional flags, which must come first:","title":"New Way"},{"location":"reference/executables/#-no-assert-version","text":"Do not print an error and exit Bash if the minimum Bash version cannot be met. Instead, don't source any dependencies, only run the executable. This is useful if you want an escape hatch from the default behavior if Bash is not the latest version.","title":"--no-assert-version"},{"location":"reference/executables/#old-way","text":"The old way exists for backwards compatibility and is not recommended. Please migrate to the more succinct method as the old way may be removed in the future. # shellcheck shell=bash eval \"$(basalt-package-init)\" basalt.package-init || exit basalt.package-load . \"$BASALT_PACKAGE_DIR/pkg/src/bin/shelltest.sh\" main.shelltest \"$@\"","title":"Old Way"},{"location":"tutorials/getting-started/","text":"Getting Started (TODO: add output for functions) (TODO: only provide output for newly added files?) Succinctly, basalt is a fancy combination of curl , tar xaf and ln -s . It clones repositories (usually in the form of tarballs), and puts all of its man pages, completion scripts, and binaries in common folders. Let's see it in action This page assumes you have completed the Installation properly Installing an executable For this demonstration, we're going to install and use bash2048 . Note that this will still work, even if Zsh or Fish is your default shell $ basalt global add github.com/JosefZIla/bash2048 This does the following Clones JosefZIla/bash2048 to a temporary directory Extracts the latest commit into a tarball to $BASALT_GLOBAL_DATA_DIR/store/tarballs/github.com/JosefZIla/bash2048@37da5210d6d70713bc8630cf45c907102a53e3cf.tar.gz using git-archive(1) Extracts the tarball to $BASALT_GLOBAL_DATA_DIR/store/tarballs/github.com/JosefZIla/bash2048@37da5210d6d70713bc8630cf45c907102a53e3cf using tar(1) Adds a symlink from the repository's bash2048.sh script to $BASALT_GLOBAL_DATA_DIR/global/.basalt/packages/bin/bash2048.sh That's it - now you can use it! $ bash2048.sh Bash 2048 v1.1 (https://github.com/mydzor/bash2048) pieces=6 target=2048 score=60 /------+------+------+------\\ | | | | | |------+------+------+------| | 4 | | | | |------+------+------+------| | 2 | 2 | | | |------+------+------+------| | 16 | 8 | | 2 | \\------+------+------+------/ Install a Bash function For the second demonstration, we're going to install z . If you already have it installed, don't worry - it will be installed to a different location and you can remove it separately TODO: have @latest which skips the latest release (since it could be outdated) and go straight to latest commit $ basalt global add rupa/z This does the following It clones and extracts similarly to bash2048 , but instead of creating a symlink to bash2048.sh , it... Adds a symlink from the repository's z.1 man page to $BASALT_GLOBAL_DATA_DIR/global/.basalt/packages/man/man1/z.1 Now, you can display the manual right away man z You might also try to execute z.sh $ z bash: z: command not found $ z.sh bash: z.sh: command not found But it doesn't work - this is standard behavior. When looking for binaries, basalt does look at the root directory, but only for shell scripts that are marked as executable ( chmod +x z.sh ) The authors of z did not mark the file as executable because they did not intend for you to execute the file - you are supposed to source it. This is why the basalt.load function exists. This function is available to you after running basalt global init <shell> $ basalt.load --global --dry github.com/rupa/z z.sh Would have sourced file '/home/edwin/.local/share/basalt/global/.basalt/packages/github.com/rupa/z@v1.9/z.sh' Now, use the basalt-load to source z.sh . Note that z.sh only supports either Bash or Zsh, so you need to currently be in one of those shells for this to work. $ basalt.load --global github.com/rupa/z z.sh $ z common: /tmp/tmp.MBF063fdlK/completions 29988 /tmp/tmp.MBF063fdlK/completions Note that if z does not show output, that's normal. You may need to cd to some directories to build the database If you want to do this persistently, just add this to your ~/.bashrc (or ~/.zshrc ). Remove packages If you completed both previous steps, two packages should be installed $ basalt global list Remove them with remove $ basalt global remove \\ git@github.com:JosefZIla/bash2048 \\ https://github.com/rupa/z $ basalt global list TODO: deprecate SSH urls (use ssh:// instead) Note that we specified the SSH URL and the HTTPS URL when removing. You can specify the package this way with all commands, including the add , remove , and upgrade commands And you are done! To learn more, check the reference and how-to directories","title":"Getting Started"},{"location":"tutorials/getting-started/#getting-started","text":"(TODO: add output for functions) (TODO: only provide output for newly added files?) Succinctly, basalt is a fancy combination of curl , tar xaf and ln -s . It clones repositories (usually in the form of tarballs), and puts all of its man pages, completion scripts, and binaries in common folders. Let's see it in action This page assumes you have completed the Installation properly","title":"Getting Started"},{"location":"tutorials/getting-started/#installing-an-executable","text":"For this demonstration, we're going to install and use bash2048 . Note that this will still work, even if Zsh or Fish is your default shell $ basalt global add github.com/JosefZIla/bash2048 This does the following Clones JosefZIla/bash2048 to a temporary directory Extracts the latest commit into a tarball to $BASALT_GLOBAL_DATA_DIR/store/tarballs/github.com/JosefZIla/bash2048@37da5210d6d70713bc8630cf45c907102a53e3cf.tar.gz using git-archive(1) Extracts the tarball to $BASALT_GLOBAL_DATA_DIR/store/tarballs/github.com/JosefZIla/bash2048@37da5210d6d70713bc8630cf45c907102a53e3cf using tar(1) Adds a symlink from the repository's bash2048.sh script to $BASALT_GLOBAL_DATA_DIR/global/.basalt/packages/bin/bash2048.sh That's it - now you can use it! $ bash2048.sh Bash 2048 v1.1 (https://github.com/mydzor/bash2048) pieces=6 target=2048 score=60 /------+------+------+------\\ | | | | | |------+------+------+------| | 4 | | | | |------+------+------+------| | 2 | 2 | | | |------+------+------+------| | 16 | 8 | | 2 | \\------+------+------+------/","title":"Installing an executable"},{"location":"tutorials/getting-started/#install-a-bash-function","text":"For the second demonstration, we're going to install z . If you already have it installed, don't worry - it will be installed to a different location and you can remove it separately","title":"Install a Bash function"},{"location":"tutorials/getting-started/#todo-have-latest-which-skips-the-latest-release-since-it-could-be-outdated-and-go-straight-to-latest-commit","text":"$ basalt global add rupa/z This does the following It clones and extracts similarly to bash2048 , but instead of creating a symlink to bash2048.sh , it... Adds a symlink from the repository's z.1 man page to $BASALT_GLOBAL_DATA_DIR/global/.basalt/packages/man/man1/z.1 Now, you can display the manual right away man z You might also try to execute z.sh $ z bash: z: command not found $ z.sh bash: z.sh: command not found But it doesn't work - this is standard behavior. When looking for binaries, basalt does look at the root directory, but only for shell scripts that are marked as executable ( chmod +x z.sh ) The authors of z did not mark the file as executable because they did not intend for you to execute the file - you are supposed to source it. This is why the basalt.load function exists. This function is available to you after running basalt global init <shell> $ basalt.load --global --dry github.com/rupa/z z.sh Would have sourced file '/home/edwin/.local/share/basalt/global/.basalt/packages/github.com/rupa/z@v1.9/z.sh' Now, use the basalt-load to source z.sh . Note that z.sh only supports either Bash or Zsh, so you need to currently be in one of those shells for this to work. $ basalt.load --global github.com/rupa/z z.sh $ z common: /tmp/tmp.MBF063fdlK/completions 29988 /tmp/tmp.MBF063fdlK/completions Note that if z does not show output, that's normal. You may need to cd to some directories to build the database If you want to do this persistently, just add this to your ~/.bashrc (or ~/.zshrc ).","title":"TODO: have @latest which skips the latest release (since it could be outdated) and go straight to latest commit"},{"location":"tutorials/getting-started/#remove-packages","text":"If you completed both previous steps, two packages should be installed $ basalt global list Remove them with remove $ basalt global remove \\ git@github.com:JosefZIla/bash2048 \\ https://github.com/rupa/z $ basalt global list","title":"Remove packages"},{"location":"tutorials/getting-started/#todo-deprecate-ssh-urls-use-ssh-instead","text":"Note that we specified the SSH URL and the HTTPS URL when removing. You can specify the package this way with all commands, including the add , remove , and upgrade commands And you are done! To learn more, check the reference and how-to directories","title":"TODO: deprecate SSH urls (use ssh:// instead)"},{"location":"tutorials/installation/","text":"Installation Prerequisites bash >= 4.3 GNU coreutils If you are on macOS, you need to install the latest Bash and coreutils : # Install prerequisite packages brew install bash coreutils See the full list of supported operating systems in Support Install Scripted curl -Lo- https://raw.githubusercontent.com/hyperupcall/basalt/main/scripts/install.sh | sh Manual 1. Clone repository git clone https://github.com/hyperupcall/basalt \"${XDG_DATA_HOME:-$HOME/.local/share}/basalt/source\" By default, this installs basalt to $HOME/.local/share/basalt/source 2. Add initialization script to shell profile This enables basalt to automatically setup your PATH , set completion variables, source completion files, and other things For bash , zsh , sh export PATH=\"${XDG_DATA_HOME:-$HOME/.local/share}/basalt/source/bin:$PATH\" eval \"$(basalt global init bash)\" # replace 'bash' with your shell For fish if test -n \"$XDG_DATA_HOME\" set -gx PATH $XDG_DATA_HOME/basalt/source/bin $PATH else set -gx PATH $HOME/.local/share/basalt/source/bin $PATH end basalt init fish | source And now you're done! Move on to Getting Started to learn the basics","title":"Installation"},{"location":"tutorials/installation/#installation","text":"","title":"Installation"},{"location":"tutorials/installation/#prerequisites","text":"bash >= 4.3 GNU coreutils If you are on macOS, you need to install the latest Bash and coreutils : # Install prerequisite packages brew install bash coreutils See the full list of supported operating systems in Support","title":"Prerequisites"},{"location":"tutorials/installation/#install","text":"","title":"Install"},{"location":"tutorials/installation/#scripted","text":"curl -Lo- https://raw.githubusercontent.com/hyperupcall/basalt/main/scripts/install.sh | sh","title":"Scripted"},{"location":"tutorials/installation/#manual","text":"","title":"Manual"},{"location":"tutorials/installation/#1-clone-repository","text":"git clone https://github.com/hyperupcall/basalt \"${XDG_DATA_HOME:-$HOME/.local/share}/basalt/source\" By default, this installs basalt to $HOME/.local/share/basalt/source","title":"1. Clone repository"},{"location":"tutorials/installation/#2-add-initialization-script-to-shell-profile","text":"This enables basalt to automatically setup your PATH , set completion variables, source completion files, and other things For bash , zsh , sh export PATH=\"${XDG_DATA_HOME:-$HOME/.local/share}/basalt/source/bin:$PATH\" eval \"$(basalt global init bash)\" # replace 'bash' with your shell For fish if test -n \"$XDG_DATA_HOME\" set -gx PATH $XDG_DATA_HOME/basalt/source/bin $PATH else set -gx PATH $HOME/.local/share/basalt/source/bin $PATH end basalt init fish | source And now you're done! Move on to Getting Started to learn the basics","title":"2. Add initialization script to shell profile"}]}